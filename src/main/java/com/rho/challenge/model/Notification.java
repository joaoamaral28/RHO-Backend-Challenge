package com.rho.challenge.model;

import com.google.gson.JsonObject;
import com.rho.challenge.service.ServiceParameters;

import javax.persistence.*;
import java.sql.Timestamp;
import java.time.Instant;

/**
 * Class representing a notification generated by the server when a certain client
 * has surpassed the cumulative threshold amount of bets in the defined bet processing window
 */
@Entity
@Table(name="notifications")
public class Notification {

    /**
     * Internal notification ID used for database indexing
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long notificationId;

    /**
     * ID of the user
     */
    private Integer accountId;

    /**
     * Cumulative total value of the account bets in the current bet processing window
     */
    private Double cumulative;

    /**
     * Timestamp representing the time the notification was generated
     */
    private Timestamp time;

    /**
     * Creates a new Notification with the given account ID and the account total bet cumulative amount
     *
     * @param accountId ID of the user
     * @param cumulative Total bet amount of the user within the bet processing window
     */
    public Notification(Integer accountId, Double cumulative){
        if(accountId <= 0)
            throw new IllegalArgumentException("Account ID must be a positive integer");
        else if(cumulative < ServiceParameters.THRESHOLD)
            throw new IllegalArgumentException("Cumulative value must exceed " + ServiceParameters.THRESHOLD + " value");
        this.accountId = accountId;
        this.cumulative = cumulative;
        //this.time = new Timestamp(System.currentTimeMillis());
        this.time = Timestamp.from(Instant.now());
    }

    /* aux constructor required for Notification instantiation upon equivalent data fetch from database */
    public Notification(Integer accountId, Double cumulative, Timestamp time){
        this.accountId = accountId;
        this.cumulative = cumulative;
        this.time = time;
    }

    /* default constructor */
    public Notification(){

    }

    /**
     * Returns the user ID of the account
     * @return ID of the user
     */
    public Integer getAccountId(){
        return this.accountId;
    }

    /**
     * Returns the total bet amount of the user within the bet processing window
     * @return Cumulative bet amount
     */
    public Double getCumulative(){
        return this.cumulative;
    }

    /**
     * Returns the time of Notification generation
     * @return Timestamp time
     */
    public Timestamp getTime(){
        return this.time;
    }

    /**
     * Returns the Notification as a JSON string
     * @return JSON string representing the Notification
     */
    public String toJSONString(){
        JsonObject json = new JsonObject();
        json.addProperty("accountId", this.accountId);
        json.addProperty("cumulative", this.cumulative);
        //json.addProperty("time", this.time.toString());
        return json.toString();
    }

    @Override
    public String toString(){
        return "Notification { accountId: "+ this.accountId + ", cumulative: " + this.cumulative +  ", timestamp:" + this.time + " }";
    }

    /* must override equals method in order to adapt to the edge case where equal notifications timestamps
    * in testing differed from one another by less than a millisecond and would result a false equivalence
    * Example: Notification { accountId: 1, cumulative: 120.0, timestamp:2020-07-06 00:51:38.3539101 }
    *          Notification { accountId: 1, cumulative: 120.0, timestamp:2020-07-06 00:51:38.338439 }
    * */
    @Override
    public boolean equals(Object o){

        /* all Notification attributes are equal */
        if(o == this){
            return true;
        }

        if(!(o instanceof Notification)){
            return false;
        }

        Notification n = (Notification) o;

        // compare notifications timestamps while discarding milliseconds
        if(Long.compare(this.time.getTime()/1000 , (n.getTime().getTime()/1000)) != 0){
            return false;
        }

        // compare remaining data members
        return (Integer.compare(this.accountId, n.getAccountId()) == 0) && (Double.compare(this.cumulative, n.getCumulative()) == 0);
    }

}
